\subsection{Internal gem5 Improvements and Features}
\label{sec:internal}

It is important to recognize not only all of the ground-breaking additions to the models in gem5, but also general improvements to the simulation infrastructure.
Although these improvements do not always result in new research findings, they are a key \emph{enabling factor} for the research conducted using gem5.

The simulator core of gem5 provides support for event-driven execution, statistics, and many other important functions.
These parts of the simulator are some of the most stable components, and, as part of the gem5-20 release and in the subsequent releases, we will be defining stable APIs for these interfaces.
By making these interfaces \emph{stable} APIs, it will facilitate long-term support for integrating other simulators (e.g., SST~\ref{sec:sst} and SystemC~\ref{sec:systemc}) and projects that build off of gem5 (e.g., gem5-gpu~\cite{}, gem5-aladdin~\cite{}, and many others.)

\subsubsection[HDF5 Support]{HDF5 Support\footnote{by Andreas Sandberg}}

A major change in the latest gem5 release is the new statistics API.
While the driver for this API was to improve support for hierarchical statistics formats like HDF5~\cite{}, there are other more tangible benefits as well.
Unlike the old API where all statistics live in the same namespace, the new API introduces a notion of statistics groups.
In most typical use cases, statistics are bound to the current SimObject's group, which is then bound to its parent by the runtime.
This ensures that there is a tree of statistics groups that match the SimObject graph.
However, groups are not limited to SimObject.
Behind the scenes, this reduces the amount of boiler plate code when defining statistics and makes the code far less error prone.
The new API also brings benefits to simulation scripts.
A feature many users have requested in the past has been the ability to dump statistics for a subset of the object graph.
This is now possible by passing a SimObject to the stat dump call, which limits the statistics dump to that subtree of the graph.

With the new statistics API in place, it became possible to support hierarchical data formats like HDF5.
Unlike gem5's traditional text-based statistics files, HDF5 stores data in a binary file format that resembles a file system.
Unlike the traditional text files, HDF5 has a rich ecosystem of tools and official bindings for many popular languages, including Python and R.
 In addition to making analysis easier, the HDF5 backend is optimized for storing time series.
HDF5 files internally store data as N-dimensional matrices.
In gem5's implementation, we use one dimension for time and the remaining dimensions for the statistic we want to represent.
For example, a scalar statistic is represented as a 1-dimensional vector.
When analyzing such series using Python, the HDF5 backend imports such data sets as a standard NumPy array that can be used in common data analysis and visualization flows.
The additional data needed to support filesystem-like structures inside the stat files introduces some storage overheads.
However, these are quickly amortized when sampling statistics since the incremental storage needed for every sample is orders of magnitude smaller than the traditional text-based statistics format.

\subsubsection[Python 3]{Python 3\footnote{by Andreas Sandberg and Giacomo Travaglini}}

One of the main features which separates gem5 from other architectural simulators is its robust support for scripting.
The main interface to configuring and running gem5 simulations is Python scripts.
While the fundamental design has not changed, there have been many changes to the underlying implementation over the past years.
The original implementation frequently suffered from bugs in the code generated by SWIG and usability was hampered by poor adherence to modern standards in SWIG's C++ parser.
The move to PyBind11~\cite{} greatly improved the reliability of the bindings by removing the need for a separate C++ parser, and made it easier to expose new functionality to Python in a reliable and type-safe manner.

The move away from SWIG to PyBind11 provided a good starting point for the more ambitious project of making gem5 Python 3 compatible.
Making gem5 Python 3 compatible has not added any new features yet, but it ensures that the simulator will continue to run on Linux distributions that are released in 2020 and onwards.
It does however enable exciting improvements under the hood.
A couple of good examples are type annotations that can be used to enable better static code analysis and greatly improved string formatting.
Our ambition is to completely phase out Python 2 support in the near future to benefit from these new features.

\subsubsection[Asynchronous Modeling in gem5]{Asynchronous Modeling in gem5\footnote{by Giacomo Travaglini}}

The difficulties of writing a complex device/hw model within gem5 is that your model needs to be able to work and be representative of the simulated hardware in both atomic and timing mode.

For simple devices which only respond to requests, this is usually not a concern.
The situation gets worse when the device can send requests and response or has DMA capabilities.
A method generating and forwarding a read packet needs to differentiate between atomic and timing behavior by handling the first with a blocking operation (the read returns the value as soon as the forwarding method returns) and the second with a non-blocking call: the value will be returned later in time.
The situation becomes dramatic in timing mode if multiple sequential DMAs are stacked so that any read operation depends on previous ones; this is the case for page table walks for example.

This software design problem has been elegantly solved using coroutines.
Coroutines allow you to execute your task, checkpoint it, and resume it later from where you stopped.
To be more specific to our use case, you can tag your DMA packets with the coroutine itself, and you could resume the coroutine once the device receives the read response.

While waiting for coroutines to be fully supported in C++20, we've implemented a coroutine library within gem5 that allows developers to use coroutines to generate asynchronous models.
The coroutine class is built on top of a ``Fiber'' class, which was a pre-existing symmetric coroutine implementation, and it provides boost-like~\cite{} APIs to the user.

At the moment coroutines are used by the SMMUv3 model developed and the GICv3 ITS model (Interrupt Translation Service).
There are many other use cases for this API in other gem5 models, and we are planning on updating those models in the future.
